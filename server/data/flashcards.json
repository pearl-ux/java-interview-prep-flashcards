[
  {
    "question": "Explain the differences between ArrayList and LinkedList.",
    "answer": "<p><strong>ArrayList:</strong></p><ul><li>Implements List using dynamic array</li><li>Fast random access (O(1))</li><li>Slow insertions/deletions (O(n))</li><li>Better for frequent access, rare modifications</li></ul><p><strong>LinkedList:</strong></p><ul><li>Implements List and Deque using doubly linked list</li><li>Slow random access (O(n))</li><li>Fast insertions/deletions (O(1))</li><li>Better for frequent modifications, rare random access</li></ul>",
    "category": "Collections",
    "difficulty": "medium"
  },
  {
    "question": "What is the difference between '==' and 'equals()' in Java?",
    "answer": "<p><strong>'==' operator:</strong></p><ul><li>Compares object references (memory addresses)</li><li>Checks if both references point to the same object</li><li>For primitives, compares actual values</li></ul><p><strong>'equals()' method:</strong></p><ul><li>Defined in Object class, but often overridden</li><li>Default implementation uses '==' comparison</li><li>Typically overridden to compare object contents</li><li>String, Integer, etc. override equals() to compare values</li></ul>",
    "category": "Core Java",
    "difficulty": "easy"
  },
  {
    "question": "Explain Java's memory model and how it relates to concurrency.",
    "answer": "<p>Java Memory Model (JMM) specifies:</p><ul><li>How threads interact through memory</li><li>Rules for visibility of changes across threads</li><li>Happens-before relationship between actions</li></ul><p>Key aspects:</p><ul><li>Each thread has a working memory (cache)</li><li>Variables may be stored in working memory or main memory</li><li>volatile keyword ensures visibility across threads</li><li>synchronized blocks establish happens-before relationships</li><li>JMM prevents certain reorderings of operations</li><li>Memory barriers created by synchronization, volatile, final fields</li></ul><p>Concurrency implications:</p><ul><li>Without proper synchronization: data races, visibility issues</li><li>Thread interference without atomic operations</li><li>JMM underpins higher-level concurrency utilities like locks, atomics, and concurrent collections</li></ul>",
    "category": "Multithreading",
    "difficulty": "hard"
  },
  {
    "question": "Describe the Singleton design pattern and its implementation in Java.",
    "answer": "<p><strong>Singleton Pattern:</strong> Ensures a class has only one instance and provides a global point of access to it.</p><p><strong>Implementation approaches:</strong></p><pre><code>// Eager initialization\npublic class EagerSingleton {\n    private static final EagerSingleton INSTANCE = new EagerSingleton();\n    \n    private EagerSingleton() {}\n    \n    public static EagerSingleton getInstance() {\n        return INSTANCE;\n    }\n}</code></pre><pre><code>// Lazy initialization (thread-safe)\npublic class LazySingleton {\n    private static volatile LazySingleton instance;\n    \n    private LazySingleton() {}\n    \n    public static LazySingleton getInstance() {\n        if (instance == null) {\n            synchronized (LazySingleton.class) {\n                if (instance == null) {\n                    instance = new LazySingleton();\n                }\n            }\n        }\n        return instance;\n    }\n}</code></pre><pre><code>// Enum Singleton (recommended)\npublic enum EnumSingleton {\n    INSTANCE;\n    \n    public void doSomething() {\n        // Implementation\n    }\n}</code></pre><p><strong>Considerations:</strong></p><ul><li>Thread safety</li><li>Lazy vs eager initialization</li><li>Serialization safety</li><li>Protection against reflection attacks</li></ul>",
    "category": "Design Patterns",
    "difficulty": "medium"
  },
  {
    "question": "What are the access modifiers in Java and what do they do?",
    "answer": "<p>Java has four access modifiers:</p><ul><li><strong>public:</strong> Accessible from any class</li><li><strong>protected:</strong> Accessible within the same package and by subclasses (even in different packages)</li><li><strong>default (no modifier):</strong> Accessible only within the same package</li><li><strong>private:</strong> Accessible only within the same class</li></ul><p>Access levels from most to least restrictive:</p><ol><li>private</li><li>default (package-private)</li><li>protected</li><li>public</li></ol><p>Usage examples:</p><ul><li>Public classes, interfaces, methods for API exposure</li><li>Protected methods for inheritance</li><li>Default access for package-level implementation details</li><li>Private fields and helper methods for encapsulation</li></ul>",
    "category": "Core Java",
    "difficulty": "easy"
  },
  {
    "question": "Explain the different types of Garbage Collectors in Java and their use cases.",
    "answer": "<p>Java offers several garbage collector implementations:</p><ul><li><strong>Serial Collector:</strong> Single-threaded, suitable for small applications with small heaps on client machines</li><li><strong>Parallel Collector:</strong> Multiple threads for GC, focuses on throughput, good for applications that can tolerate pauses</li><li><strong>Concurrent Mark Sweep (CMS):</strong> Minimizes pauses by performing most work concurrently, good for applications requiring low latency</li><li><strong>G1 (Garbage First):</strong> Server-style collector, divides heap into regions, prioritizes regions with most garbage, balances throughput and latency</li><li><strong>ZGC (Z Garbage Collector):</strong> Designed for very low pause times (less than 10ms) on large heaps</li><li><strong>Shenandoah:</strong> Similar to ZGC, aims for low pause times regardless of heap size</li></ul><p>Selection considerations:</p><ul><li>Application requirements (throughput vs latency)</li><li>Available memory</li><li>CPU cores</li><li>Pause time requirements</li></ul><p>Tuning parameters:</p><ul><li>Heap size (-Xms, -Xmx)</li><li>GC algorithm selection (-XX:+UseSerialGC, -XX:+UseParallelGC, etc.)</li><li>Generation sizing</li><li>Collection triggers</li></ul>",
    "category": "JVM Internals",
    "difficulty": "hard"
  },
  {
    "question": "What are Java Collections and how are they organized?",
    "answer": "<p>Java Collections Framework provides a unified architecture for representing and manipulating collections:</p><p><strong>Main interfaces:</strong></p><ul><li><strong>Collection:</strong> Root interface (except Map)</li><li><strong>List:</strong> Ordered collection, allows duplicates (ArrayList, LinkedList, Vector)</li><li><strong>Set:</strong> No duplicates (HashSet, LinkedHashSet, TreeSet)</li><li><strong>Queue/Deque:</strong> Ordered for processing (LinkedList, PriorityQueue, ArrayDeque)</li><li><strong>Map:</strong> Key-value pairs, no duplicate keys (HashMap, LinkedHashMap, TreeMap, ConcurrentHashMap)</li></ul><p><strong>Implementation characteristics:</strong></p><ul><li><strong>ArrayList:</strong> Dynamic array, fast random access</li><li><strong>LinkedList:</strong> Doubly-linked list, fast insertions/deletions</li><li><strong>HashSet:</strong> Uses HashMap, constant-time operations</li><li><strong>TreeSet:</strong> Red-black tree, elements sorted naturally</li><li><strong>HashMap:</strong> Hash table implementation, constant-time operations</li><li><strong>TreeMap:</strong> Red-black tree, keys sorted naturally</li></ul><p><strong>Utility methods:</strong> Collections class provides algorithms like sorting, searching, shuffling</p>",
    "category": "Collections",
    "difficulty": "medium"
  },
  {
    "question": "What are the SOLID principles in object-oriented design?",
    "answer": "<p>SOLID is an acronym for five design principles:</p><ul><li><strong>S - Single Responsibility Principle:</strong> A class should have only one reason to change</li><li><strong>O - Open/Closed Principle:</strong> Classes should be open for extension but closed for modification</li><li><strong>L - Liskov Substitution Principle:</strong> Subtypes must be substitutable for their base types without altering program correctness</li><li><strong>I - Interface Segregation Principle:</strong> Clients shouldn't depend on interfaces they don't use</li><li><strong>D - Dependency Inversion Principle:</strong> High-level modules shouldn't depend on low-level modules; both should depend on abstractions</li></ul><p><strong>Benefits:</strong></p><ul><li>More maintainable code</li><li>Easier to extend</li><li>More testable</li><li>More reusable components</li><li>Reduced tight coupling</li></ul>",
    "category": "Design Patterns",
    "difficulty": "medium"
  },
  {
    "question": "How does Java handle exceptions?",
    "answer": "<p>Java uses a try-catch-finally mechanism for exception handling:</p><pre><code>try {\n    // Code that might throw an exception\n} catch (ExceptionType1 e1) {\n    // Handle exception of ExceptionType1\n} catch (ExceptionType2 e2) {\n    // Handle exception of ExceptionType2\n} finally {\n    // Code that always executes\n}</code></pre><p><strong>Exception hierarchy:</strong></p><ul><li><strong>Throwable</strong>: Root class<ul><li><strong>Error</strong>: Serious problems, not typically caught (OutOfMemoryError, StackOverflowError)</li><li><strong>Exception</strong>: Problems that can be handled<ul><li><strong>RuntimeException</strong>: Unchecked exceptions (NullPointerException, ArrayIndexOutOfBoundsException)</li><li>Other exceptions: Checked exceptions (IOException, SQLException)</li></ul></li></ul></li></ul><p><strong>Checked vs Unchecked:</strong></p><ul><li><strong>Checked exceptions:</strong> Must be declared or caught</li><li><strong>Unchecked exceptions:</strong> Don't need to be declared or caught</li></ul><p><strong>Try-with-resources:</strong></p><pre><code>try (Resource resource = new Resource()) {\n    // Use resource\n} // Resource automatically closed</code></pre><p><strong>Custom exceptions:</strong></p><pre><code>public class CustomException extends Exception {\n    public CustomException(String message) {\n        super(message);\n    }\n}</code></pre>",
    "category": "Core Java",
    "difficulty": "medium"
  },
  {
    "question": "What is reflection in Java and when would you use it?",
    "answer": "<p>Reflection is the ability of code to examine and modify the behavior of classes, interfaces, fields, and methods at runtime.</p><p><strong>Capabilities:</strong></p><ul><li>Examine class structure, methods, fields</li><li>Create new objects</li><li>Invoke methods</li><li>Access and modify fields</li><li>Access annotations</li></ul><p><strong>Example:</strong></p><pre><code>// Get class object\nClass<?> clazz = MyClass.class;\n\n// Get constructor and create instance\nConstructor<?> constructor = clazz.getConstructor();\nObject obj = constructor.newInstance();\n\n// Get and invoke method\nMethod method = clazz.getDeclaredMethod(\"myMethod\", String.class);\nmethod.setAccessible(true); // Access private method\nmethod.invoke(obj, \"parameter\");\n\n// Get and modify field\nField field = clazz.getDeclaredField(\"myField\");\nfield.setAccessible(true); // Access private field\nfield.set(obj, \"new value\");</code></pre><p><strong>Use cases:</strong></p><ul><li>Frameworks like Spring, Hibernate</li><li>Serialization/deserialization</li><li>Testing and mocking</li><li>Debugging tools</li><li>Runtime code generation</li><li>Dependency injection</li></ul><p><strong>Drawbacks:</strong></p><ul><li>Performance overhead</li><li>Type safety loss</li><li>Security concerns</li><li>Maintenance challenges</li><li>May break encapsulation</li></ul>",
    "category": "Core Java",
    "difficulty": "hard"
  },
  {
    "question": "How does Java implement multithreading?",
    "answer": "<p>Java provides multiple ways to create and manage threads:</p><p><strong>1. Extending Thread class:</strong></p><pre><code>class MyThread extends Thread {\n    public void run() {\n        // Thread logic here\n    }\n}\n\n// Usage\nMyThread thread = new MyThread();\nthread.start();</code></pre><p><strong>2. Implementing Runnable interface:</strong></p><pre><code>class MyRunnable implements Runnable {\n    public void run() {\n        // Thread logic here\n    }\n}\n\n// Usage\nThread thread = new Thread(new MyRunnable());\nthread.start();</code></pre><p><strong>3. Using Executor Framework:</strong></p><pre><code>ExecutorService executor = Executors.newFixedThreadPool(5);\nexecutor.submit(() -> {\n    // Thread logic here\n});\nexecutor.shutdown();</code></pre><p><strong>Synchronization mechanisms:</strong></p><ul><li><strong>synchronized keyword:</strong> For methods or blocks</li><li><strong>volatile keyword:</strong> Ensures visibility across threads</li><li><strong>wait()/notify():</strong> For inter-thread communication</li><li><strong>Lock interface:</strong> More flexible than synchronized</li><li><strong>Atomic classes:</strong> For lock-free thread-safe operations</li><li><strong>ThreadLocal:</strong> Thread-specific storage</li></ul><p><strong>concurrent package:</strong></p><ul><li>BlockingQueue, ConcurrentHashMap, CopyOnWriteArrayList</li><li>CountDownLatch, CyclicBarrier, Semaphore</li><li>CompletableFuture for asynchronous programming</li></ul>",
    "category": "Multithreading",
    "difficulty": "medium"
  },
  {
    "question": "Explain the Spring Framework's core features.",
    "answer": "<p>Spring Framework is a comprehensive framework for Java applications with these core features:</p><p><strong>1. Dependency Injection (DI) / Inversion of Control (IoC):</strong></p><ul><li>Bean container manages object lifecycles</li><li>Reduces coupling between components</li><li>Constructor, setter, and field injection</li></ul><p><strong>2. Aspect-Oriented Programming (AOP):</strong></p><ul><li>Separates cross-cutting concerns (logging, security, transactions)</li><li>Proxy-based implementation</li><li>Join points, pointcuts, and advice</li></ul><p><strong>3. Spring MVC:</strong></p><ul><li>Web framework with front controller pattern</li><li>Annotation-based controller mapping</li><li>View resolution and rendering</li></ul><p><strong>4. Transaction Management:</strong></p><ul><li>Declarative transaction management</li><li>Consistent API across different transaction systems</li><li>Integration with various data access technologies</li></ul><p><strong>5. Data Access:</strong></p><ul><li>JDBC abstraction layer</li><li>ORM integration (Hibernate, JPA)</li><li>Consistent exception hierarchy</li></ul><p><strong>6. Spring Boot:</strong></p><ul><li>Rapid application development</li><li>Opinionated configuration (auto-configuration)</li><li>Embedded servers</li><li>Production-ready features</li></ul><p><strong>7. Spring Security:</strong></p><ul><li>Authentication and authorization</li><li>Protection against common attacks</li><li>Integration with various security systems</li></ul><p><strong>8. Spring Cloud:</strong></p><ul><li>Tools for building distributed systems</li><li>Service discovery, circuit breakers, configuration management</li></ul>",
    "category": "Spring & Hibernate",
    "difficulty": "medium"
  },
  {
    "question": "What are the four main principles of Object-Oriented Programming?",
    "answer": "<p><strong>1. Encapsulation:</strong></p><ul><li>Bundling data (attributes) and methods that operate on the data into a single unit (class)</li><li>Controlling access to data through access modifiers (public, private, protected)</li><li>Information hiding, exposing only what's necessary</li><li>Example: private fields with public getters/setters</li></ul><p><strong>2. Inheritance:</strong></p><ul><li>Allowing a class (subclass) to inherit properties and behavior from another class (superclass)</li><li>Promotes code reuse and establishes is-a relationship</li><li>Implemented in Java using 'extends' keyword</li><li>Example: <code>class Car extends Vehicle</code></li></ul><p><strong>3. Polymorphism:</strong></p><ul><li>Ability of objects to take different forms depending on context</li><li>Method overriding: subclass implements a method of superclass</li><li>Method overloading: multiple methods with same name but different parameters</li><li>Example: <code>shape.draw()</code> behaves differently for Circle vs Rectangle</li></ul><p><strong>4. Abstraction:</strong></p><ul><li>Hiding implementation details, showing only functionality</li><li>Focus on what an object does rather than how it does it</li><li>Implemented via interfaces and abstract classes</li><li>Example: <code>interface Drawable { void draw(); }</code></li></ul>",
    "category": "Core Java",
    "difficulty": "easy"
  },
  {
    "question": "How does HashMap work internally in Java?",
    "answer": "<p>HashMap is a hash table implementation of the Map interface. Its internal working:</p><p><strong>Data Structure:</strong></p><ul><li>Array of nodes (buckets)</li><li>Each node contains key-value pair and links to next node (for collision resolution)</li><li>In Java 8+, buckets may convert to balanced trees when threshold exceeded</li></ul><p><strong>Key Operations:</strong></p><p>1. <strong>put(K key, V value):</strong></p><ul><li>Calculate hash code for key</li><li>Map hash to bucket index: <code>index = hash & (n-1)</code> where n is bucket array size</li><li>If bucket empty, create new node</li><li>If key exists, replace value</li><li>If collision, either link to existing nodes or add to tree</li><li>If load factor threshold exceeded, rehash (resize to double capacity)</li></ul><p>2. <strong>get(Object key):</strong></p><ul><li>Calculate hash and index</li><li>Search bucket for matching key (equals method)</li><li>Return associated value if found, null otherwise</li></ul><p><strong>Important characteristics:</strong></p><ul><li>O(1) average time complexity for get/put operations</li><li>Keys should override hashCode() and equals() correctly</li><li>Default load factor = 0.75 (balance between space and efficiency)</li><li>Not thread-safe (use ConcurrentHashMap for concurrent access)</li><li>Iteration order not guaranteed (use LinkedHashMap for predictable order)</li></ul>",
    "category": "Collections",
    "difficulty": "hard"
  },
  {
    "question": "What is the Java ClassLoader and how does it work?",
    "answer": "<p>The ClassLoader is a part of the JVM that loads class files into memory.</p><p><strong>Types of ClassLoaders:</strong></p><ol><li><strong>Bootstrap ClassLoader:</strong> Loads core Java classes from /lib directory (rt.jar, etc.)</li><li><strong>Extension ClassLoader:</strong> Child of Bootstrap, loads classes from /lib/ext directory</li><li><strong>Application ClassLoader:</strong> Child of Extension, loads classes from application classpath</li><li><strong>Custom ClassLoaders:</strong> For specialized loading requirements</li></ol><p><strong>ClassLoader Hierarchy and Delegation Model:</strong></p><ul><li>Child-first delegation: Request class from parent before trying to load it</li><li>Prevents loading same class multiple times</li><li>Search order: Bootstrap → Extension → Application → Custom</li></ul><p><strong>Class Loading Process:</strong></p><ol><li><strong>Loading:</strong> Finding and reading the binary representation (.class file)</li><li><strong>Linking:</strong><ul><li>Verification: Ensures bytecode is valid and safe</li><li>Preparation: Allocates memory for static fields, initializes with default values</li><li>Resolution: Resolves symbolic references to actual references</li></ul></li><li><strong>Initialization:</strong> Executes static initializers and initializers for static fields</li></ol><p><strong>Use Cases for Custom ClassLoaders:</strong></p><ul><li>Dynamic class loading / hot swapping</li><li>Application servers (loading isolated applications)</li><li>Frameworks with plugin architectures</li><li>Loading encrypted class files</li><li>Generating classes at runtime</li></ul>",
    "category": "JVM Internals",
    "difficulty": "hard"
  },
  {
    "question": "What is a Java Stream and how does it differ from collections?",
    "answer": "<p>Java Stream API (introduced in Java 8) provides a functional approach to processing sequences of elements.</p><p><strong>Characteristics of Streams:</strong></p><ul><li><strong>Not a data structure:</strong> Streams don't store elements, they process elements from a source</li><li><strong>Functional in nature:</strong> Operations produce results without modifying the source</li><li><strong>Laziness-seeking:</strong> Many stream operations are deferred until needed</li><li><strong>Possibly unbounded:</strong> Collections have finite size, streams can be infinite</li><li><strong>Consumable:</strong> A stream can only be traversed once</li></ul><p><strong>Key differences from collections:</strong></p><ul><li>Collections focus on data storage and access; streams focus on computations</li><li>Collections are eagerly constructed; streams are lazily constructed</li><li>Collections support iteration and direct access; streams support declarative operations</li><li>Collections can be traversed multiple times; streams are traversed only once</li></ul><p><strong>Stream operations:</strong></p><ul><li><strong>Intermediate operations:</strong> Return a new stream (filter, map, sorted, etc.)</li><li><strong>Terminal operations:</strong> Produce a result or side-effect (collect, reduce, forEach, etc.)</li></ul><p><strong>Example:</strong></p><pre><code>List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\n\n// Traditional approach\nList&lt;Integer&gt; evenSquares = new ArrayList&lt;&gt;();\nfor (Integer num : numbers) {\n    if (num % 2 == 0) {\n        evenSquares.add(num * num);\n    }\n}\n\n// Stream approach\nList&lt;Integer&gt; evenSquaresStream = numbers.stream()\n    .filter(num -> num % 2 == 0)\n    .map(num -> num * num)\n    .collect(Collectors.toList());</code></pre>",
    "category": "Core Java",
    "difficulty": "medium"
  },
  {
    "question": "What are Java annotations and how are they used?",
    "answer": "<p>Annotations are metadata that can be added to Java code elements (classes, methods, fields, etc.).</p><p><strong>Syntax:</strong></p><pre><code>@AnnotationName(attribute1 = value1, attribute2 = value2)\npublic void someMethod() { }</code></pre><p><strong>Built-in annotations:</strong></p><ul><li><strong>@Override:</strong> Indicates method overrides a superclass method</li><li><strong>@Deprecated:</strong> Marks elements that should no longer be used</li><li><strong>@SuppressWarnings:</strong> Suppresses compiler warnings</li><li><strong>@FunctionalInterface:</strong> Indicates interface is a functional interface</li><li><strong>@SafeVarargs:</strong> Suppresses warnings for varargs methods</li></ul><p><strong>Creating custom annotations:</strong></p><pre><code>@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.METHOD)\npublic @interface MyAnnotation {\n    String value() default \"\";\n    int count() default 0;\n}</code></pre><p><strong>Retention policies:</strong></p><ul><li><strong>SOURCE:</strong> Discarded during compilation</li><li><strong>CLASS:</strong> Stored in class file but not available at runtime</li><li><strong>RUNTIME:</strong> Available at runtime through reflection</li></ul><p><strong>Target types:</strong></p><ul><li>TYPE (class, interface), METHOD, FIELD, PARAMETER, etc.</li></ul><p><strong>Common uses:</strong></p><ul><li>Configuration (Spring, JPA, etc.)</li><li>Code generation (Lombok)</li><li>Runtime processing (validation, serialization)</li><li>Compile-time processing (annotation processors)</li><li>Documentation (Javadoc)</li></ul><p><strong>Processing annotations:</strong></p><pre><code>Method method = obj.getClass().getMethod(\"someMethod\");\nif (method.isAnnotationPresent(MyAnnotation.class)) {\n    MyAnnotation annotation = method.getAnnotation(MyAnnotation.class);\n    String value = annotation.value();\n    int count = annotation.count();\n}</code></pre>",
    "category": "Core Java",
    "difficulty": "medium"
  },
  {
    "question": "What is the Observer design pattern and when would you use it?",
    "answer": "<p>The Observer pattern defines a one-to-many dependency between objects where when one object (the subject) changes state, all its dependents (observers) are notified and updated automatically.</p><p><strong>Components:</strong></p><ul><li><strong>Subject:</strong> Maintains a list of observers and notifies them of state changes</li><li><strong>Observer:</strong> Defines an updating interface for objects that should be notified</li><li><strong>ConcreteSubject:</strong> Implements the Subject interface</li><li><strong>ConcreteObserver:</strong> Implements the Observer interface</li></ul><p><strong>Implementation in Java:</strong></p><pre><code>// Observer interface\ninterface Observer {\n    void update(String message);\n}\n\n// Subject\nclass Subject {\n    private List&lt;Observer&gt; observers = new ArrayList&lt;&gt;();\n    private String state;\n    \n    public void attach(Observer observer) {\n        observers.add(observer);\n    }\n    \n    public void detach(Observer observer) {\n        observers.remove(observer);\n    }\n    \n    public void setState(String state) {\n        this.state = state;\n        notifyObservers();\n    }\n    \n    private void notifyObservers() {\n        for (Observer observer : observers) {\n            observer.update(state);\n        }\n    }\n}\n\n// Concrete Observer\nclass ConcreteObserver implements Observer {\n    private String name;\n    \n    public ConcreteObserver(String name) {\n        this.name = name;\n    }\n    \n    @Override\n    public void update(String message) {\n        System.out.println(name + \" received: \" + message);\n    }\n}</code></pre><p><strong>Built-in Java implementation:</strong></p><ul><li>java.util.Observable (deprecated in Java 9)</li><li>java.util.Observer interface (deprecated in Java 9)</li><li>java.beans for PropertyChangeListener pattern</li><li>java.util.EventListener for Swing and AWT</li></ul><p><strong>Use cases:</strong></p><ul><li>Event handling systems</li><li>MVC architecture (Model notifies Views)</li><li>Publish-subscribe systems</li><li>UI components responding to data changes</li><li>Distributed systems for consistency</li></ul>",
    "category": "Design Patterns",
    "difficulty": "medium"
  },
  {
    "question": "Explain the differences between abstract classes and interfaces in Java.",
    "answer": "<p><strong>Abstract Classes:</strong></p><ul><li>Can have both abstract and concrete methods</li><li>Can have constructors</li><li>Can have instance variables (fields)</li><li>Can have any access modifiers</li><li>A class can extend only one abstract class</li><li>Can have static methods and fields</li><li>Can have final methods (cannot be overridden by subclasses)</li></ul><p><strong>Interfaces (before Java 8):</strong></p><ul><li>Only abstract methods</li><li>No constructors</li><li>Only constants (public static final)</li><li>All methods are implicitly public and abstract</li><li>A class can implement multiple interfaces</li></ul><p><strong>Interfaces (Java 8 and later):</strong></p><ul><li>Can have default methods (with implementation)</li><li>Can have static methods</li><li>Still no instance variables</li></ul><p><strong>Interfaces (Java 9 and later):</strong></p><ul><li>Can have private methods (helper methods for default methods)</li></ul><p><strong>When to use Abstract Class:</strong></p><ul><li>When you want to share code among closely related classes</li><li>When classes that extend your abstract class have many common methods or fields</li><li>When you need access modifiers other than public</li><li>When you need to declare non-static or non-final fields</li></ul><p><strong>When to use Interface:</strong></p><ul><li>When unrelated classes would implement your interface</li><li>When you want to specify the behavior of a class without concern for implementation</li><li>When you want a class to be able to extend another class in addition to implementing your type</li><li>To achieve multiple inheritance of type</li></ul><p><strong>Example:</strong></p><pre><code>// Abstract class\nabstract class Animal {\n    private String name;\n    \n    public Animal(String name) {\n        this.name = name;\n    }\n    \n    public String getName() {\n        return name;\n    }\n    \n    // Abstract method\n    abstract void makeSound();\n    \n    // Concrete method\n    public void eat() {\n        System.out.println(name + \" is eating\");\n    }\n}\n\n// Interface\ninterface Swimable {\n    // Constant\n    int MAX_DEPTH = 100;\n    \n    // Abstract method\n    void swim();\n    \n    // Default method (Java 8+)\n    default void dive() {\n        System.out.println(\"Diving\");\n    }\n    \n    // Static method (Java 8+)\n    static boolean canSwimInDeepWater(int depth) {\n        return depth <= MAX_DEPTH;\n    }\n}</code></pre>",
    "category": "Core Java",
    "difficulty": "medium"
  },
  {
    "question": "What are Java Generics and why are they used?",
    "answer": "<p>Generics enable types (classes and interfaces) to be parameters when defining classes, interfaces, and methods. Benefits:</p><ul><li>Compile-time type safety</li><li>Elimination of casts</li><li>Enabling generic algorithms</li></ul><p><strong>Basic syntax:</strong></p><pre><code>// Generic class\nclass Box&lt;T&gt; {\n    private T content;\n    \n    public void set(T content) {\n        this.content = content;\n    }\n    \n    public T get() {\n        return content;\n    }\n}\n\n// Usage\nBox&lt;Integer&gt; intBox = new Box&lt;&gt;();\nintBox.set(10);\nInteger content = intBox.get(); // No casting needed</code></pre><p><strong>Generic methods:</strong></p><pre><code>public &lt;T&gt; T findMax(List&lt;T&gt; list, Comparator&lt;T&gt; comp) {\n    // Implementation\n}</code></pre><p><strong>Bounded type parameters:</strong></p><pre><code>// Upper bound\npublic &lt;T extends Number&gt; double sum(List&lt;T&gt; list) {\n    // Can use Number methods on T\n}\n\n// Multiple bounds\npublic &lt;T extends Number & Comparable&lt;T&gt;&gt; T findMax(List&lt;T&gt; list) {\n    // Implementation\n}</code></pre><p><strong>Wildcards:</strong></p><ul><li><strong>Unbounded:</strong> <code>List&lt;?&gt;</code> - Any type of list</li><li><strong>Upper bounded:</strong> <code>List&lt;? extends Number&gt;</code> - List of Number or subclasses</li><li><strong>Lower bounded:</strong> <code>List&lt;? super Integer&gt;</code> - List of Integer or superclasses</li></ul><p><strong>Type erasure:</strong></p><ul><li>Generics information exists only at compile time</li><li>At runtime, generics are replaced with bounds or Object</li><li>Leads to certain limitations (can't create instances of type parameters, etc.)</li></ul><p><strong>PECS principle:</strong></p><ul><li><strong>Producer Extends, Consumer Super</strong></li><li>Use <code>extends</code> when you only get values out (read)</li><li>Use <code>super</code> when you only put values in (write)</li></ul>",
    "category": "Core Java",
    "difficulty": "hard"
  },
  {
    "question": "How does Spring Boot autoConfiguration work?",
    "answer": "<p>Spring Boot's auto-configuration automatically configures a Spring application based on the dependencies present in the classpath.</p><p><strong>Key components:</strong></p><ol><li><strong>@SpringBootApplication annotation:</strong> A convenience annotation that includes:</li><ul><li>@Configuration: Tags the class as a source of bean definitions</li><li>@EnableAutoConfiguration: Enables Spring Boot's auto-configuration</li><li>@ComponentScan: Scans for components in the current package and sub-packages</li></ul><li><strong>Conditional annotations:</strong></li><ul><li>@ConditionalOnClass: Applies configuration if specific class is present</li><li>@ConditionalOnMissingClass: Applies if class is not present</li><li>@ConditionalOnBean: Applies if specific bean exists</li><li>@ConditionalOnMissingBean: Applies if bean doesn't exist</li><li>@ConditionalOnProperty: Applies based on property value</li><li>@ConditionalOnWebApplication: Applies if it's a web application</li></ul></ol><p><strong>Auto-configuration process:</strong></p><ol><li>Spring Boot searches for auto-configuration classes in META-INF/spring.factories files</li><li>Filters auto-configuration classes based on conditions</li><li>Applies configurations in a specific order (using @AutoConfigureAfter, @AutoConfigureBefore)</li><li>Creates and configures beans based on classpath contents</li></ol><p><strong>Example of an auto-configuration class:</strong></p><pre><code>@Configuration\n@ConditionalOnClass(DataSource.class)\n@EnableConfigurationProperties(DataSourceProperties.class)\npublic class DataSourceAutoConfiguration {\n\n    @Bean\n    @ConditionalOnMissingBean\n    public DataSource dataSource(DataSourceProperties properties) {\n        // Create and configure DataSource\n    }\n}</code></pre><p><strong>Customizing auto-configuration:</strong></p><ul><li>Override default beans with your own definitions</li><li>Set properties in application.properties/application.yml</li><li>Exclude specific auto-configurations</li></ul><pre><code>@SpringBootApplication(exclude = {DataSourceAutoConfiguration.class})</code></pre><p><strong>Debugging auto-configuration:</strong></p><ul><li>Use --debug flag or set logging.level.org.springframework.boot=DEBUG</li><li>Spring Boot will log auto-configuration report</li></ul>",
    "category": "Spring & Hibernate",
    "difficulty": "hard"
  },
  {
    "question": "What is the Java Memory Model and how does it work?",
    "answer": "<p>The Java Memory Model (JMM) specifies how the Java Virtual Machine (JVM) interacts with computer memory, particularly in a multi-threaded environment.</p><p><strong>Key concepts:</strong></p><ul><li><strong>Main memory:</strong> Shared memory visible to all threads</li><li><strong>Working memory:</strong> Each thread has its own working memory (cache)</li><li><strong>Memory actions:</strong> Read, write, lock, unlock, and other operations</li><li><strong>Happens-before relationship:</strong> Guarantees visibility of memory operations between threads</li></ul><p><strong>Memory consistency problems:</strong></p><ul><li><strong>Visibility:</strong> Changes made by one thread may not be visible to others</li><li><strong>Reordering:</strong> JVM, compiler, or CPU can reorder instructions for optimization</li></ul><p><strong>JMM guarantees:</strong></p><ol><li>Atomicity for basic operations (reading/writing to variables except longs and doubles)</li><li>Visibility when proper synchronization is used</li><li>Ordering constraints on memory operations</li></ol><p><strong>Synchronization mechanisms:</strong></p><ul><li><strong>synchronized keyword:</strong> Establishes happens-before relationships</li><li><strong>volatile keyword:</strong> Ensures changes are visible to all threads</li><li><strong>final fields:</strong> Guarantee visibility after object construction</li><li><strong>concurrent collections:</strong> Thread-safe with memory visibility guarantees</li><li><strong>java.util.concurrent utilities:</strong> AtomicInteger, locks, etc.</li></ul><p><strong>Happens-before rules:</strong></p><ol><li>Program order: Each action in a thread happens before every subsequent action in that thread</li><li>Monitor lock: Unlock happens before subsequent lock of same monitor</li><li>Volatile: Write to volatile variable happens before every subsequent read of that variable</li><li>Thread start: start() happens before any actions in the started thread</li><li>Thread termination: All actions in a thread happen before another thread detects its termination</li><li>Transitivity: If A happens before B, and B happens before C, then A happens before C</li></ol><p><strong>Example issue without proper synchronization:</strong></p><pre><code>public class SharedData {\n    private int counter = 0;\n    private boolean flag = false;\n    \n    // Thread 1\n    public void writer() {\n        counter = 42;\n        flag = true;\n    }\n    \n    // Thread 2\n    public void reader() {\n        if (flag) {\n            // counter might be 0 or 42 without proper synchronization\n            System.out.println(counter);\n        }\n    }\n}</code></pre>",
    "category": "JVM Internals",
    "difficulty": "hard"
  },
  {
    "question": "How would you implement thread-safe Singleton pattern in Java?",
    "answer": "<p>There are several ways to implement a thread-safe Singleton pattern in Java:</p><p><strong>1. Eager initialization:</strong></p><pre><code>public class EagerSingleton {\n    // Created when class is loaded - thread-safe by default\n    private static final EagerSingleton INSTANCE = new EagerSingleton();\n    \n    // Private constructor prevents external instantiation\n    private EagerSingleton() {}\n    \n    public static EagerSingleton getInstance() {\n        return INSTANCE;\n    }\n}</code></pre><p><strong>2. Lazy initialization with synchronized method:</strong></p><pre><code>public class SynchronizedSingleton {\n    private static SynchronizedSingleton instance;\n    \n    private SynchronizedSingleton() {}\n    \n    // Thread-safe but potentially low performance\n    public static synchronized SynchronizedSingleton getInstance() {\n        if (instance == null) {\n            instance = new SynchronizedSingleton();\n        }\n        return instance;\n    }\n}</code></pre><p><strong>3. Double-checked locking (DCL):</strong></p><pre><code>public class DCLSingleton {\n    // volatile ensures visibility across threads\n    private static volatile DCLSingleton instance;\n    \n    private DCLSingleton() {}\n    \n    public static DCLSingleton getInstance() {\n        if (instance == null) { // First check (not synchronized)\n            synchronized (DCLSingleton.class) {\n                if (instance == null) { // Second check (synchronized)\n                    instance = new DCLSingleton();\n                }\n            }\n        }\n        return instance;\n    }\n}</code></pre><p><strong>4. Static holder pattern:</strong></p><pre><code>public class HolderSingleton {\n    private HolderSingleton() {}\n    \n    // Inner class is only loaded when getInstance() is called\n    private static class SingletonHolder {\n        private static final HolderSingleton INSTANCE = new HolderSingleton();\n    }\n    \n    public static HolderSingleton getInstance() {\n        return SingletonHolder.INSTANCE;\n    }\n}</code></pre><p><strong>5. Enum Singleton (recommended):</strong></p><pre><code>public enum EnumSingleton {\n    INSTANCE;\n    \n    // Add fields and methods\n    private int value;\n    \n    public int getValue() {\n        return value;\n    }\n    \n    public void setValue(int value) {\n        this.value = value;\n    }\n}</code></pre><p><strong>Advantages of Enum Singleton:</strong></p><ul><li>Thread safety guaranteed by JVM</li><li>Protection against reflection attacks</li><li>Serialization safety built-in</li><li>Handles multiple classloaders correctly</li></ul><p><strong>Additional considerations:</strong></p><ul><li>Serialization: Implement readResolve() method to maintain singleton property</li><li>Reflection attacks: Add protection in constructor</li><li>Multiple classloaders: Can create multiple instances</li></ul>",
    "category": "Design Patterns",
    "difficulty": "hard"
  },
  {
    "question": "Explain Hibernate's session and EntityManager.",
    "answer": "<p>Hibernate offers two primary APIs for database interaction:</p><p><strong>1. Hibernate Native API: Session</strong></p><ul><li>Central interface for Hibernate operations</li><li>Lightweight, not thread-safe (short-lived)</li><li>Obtained from SessionFactory (thread-safe, heavyweight)</li><li>First-level cache for entities (persistence context)</li></ul><p><strong>Session lifecycle:</strong></p><pre><code>// Creating Session\nSessionFactory sessionFactory = // configuration\nSession session = sessionFactory.openSession();\nTransaction tx = null;\n\ntry {\n    tx = session.beginTransaction();\n    \n    // CRUD operations\n    User user = new User();\n    user.setName(\"John\");\n    session.save(user);  // Persist\n    \n    User loadedUser = session.get(User.class, 1L);  // Retrieve\n    loadedUser.setName(\"Updated Name\");  // Update (automatic due to persistence context)\n    \n    session.delete(loadedUser);  // Delete\n    \n    tx.commit();\n} catch (Exception e) {\n    if (tx != null) tx.rollback();\n    throw e;\n} finally {\n    session.close();  // Important\n}</code></pre><p><strong>2. JPA API: EntityManager</strong></p><ul><li>Standard Java EE specification implemented by Hibernate</li><li>Similar to Session but with standardized API</li><li>Obtained from EntityManagerFactory</li><li>Manages persistence context</li></ul><p><strong>EntityManager lifecycle:</strong></p><pre><code>// Creating EntityManager\nEntityManagerFactory emf = // configuration\nEntityManager em = emf.createEntityManager();\nEntityTransaction tx = null;\n\ntry {\n    tx = em.getTransaction();\n    tx.begin();\n    \n    // CRUD operations\n    User user = new User();\n    user.setName(\"John\");\n    em.persist(user);  // Persist\n    \n    User loadedUser = em.find(User.class, 1L);  // Retrieve\n    loadedUser.setName(\"Updated Name\");  // Update (automatic)\n    \n    em.remove(loadedUser);  // Delete\n    \n    tx.commit();\n} catch (Exception e) {\n    if (tx != null && tx.isActive()) tx.rollback();\n    throw e;\n} finally {\n    em.close();  // Important\n}</code></pre><p><strong>Comparison:</strong></p><table><tr><th>Feature</th><th>Session</th><th>EntityManager</th></tr><tr><td>Specification</td><td>Hibernate-specific</td><td>JPA standard</td></tr><tr><td>Portability</td><td>Tied to Hibernate</td><td>Works with any JPA provider</td></tr><tr><td>Flexibility</td><td>More feature-rich</td><td>Standard features only</td></tr><tr><td>Caching</td><td>First-level cache</td><td>First-level cache</td></tr><tr><td>Transactions</td><td>Transaction API</td><td>EntityTransaction</td></tr></table><p><strong>Entity states:</strong></p><ol><li><strong>Transient:</strong> Not associated with a session/persistence context</li><li><strong>Persistent:</strong> Associated with a session/persistence context</li><li><strong>Detached:</strong> Previously persistent but session closed</li><li><strong>Removed:</strong> Scheduled for deletion</li></ol>",
    "category": "Spring & Hibernate",
    "difficulty": "medium"
  },
  {
    "question": "Explain how equals() and hashCode() should be implemented.",
    "answer": "<p>Proper implementation of equals() and hashCode() is crucial, especially when using Java collections like HashMap, HashSet.</p><p><strong>equals() method:</strong></p><ul><li>Reflexive: x.equals(x) should return true</li><li>Symmetric: if x.equals(y) is true, then y.equals(x) should be true</li><li>Transitive: if x.equals(y) and y.equals(z), then x.equals(z)</li><li>Consistent: multiple invocations should return same result if objects don't change</li><li>Non-nullity: x.equals(null) should return false</li></ul><p><strong>hashCode() method:</strong></p><ul><li>Must be consistent with equals(): if x.equals(y) is true, then x.hashCode() == y.hashCode()</li><li>Should distribute objects well across hash buckets</li><li>Should be fast to compute</li><li>Should be consistent: same value during a single execution if fields don't change</li></ul><p><strong>Contract between equals() and hashCode():</strong></p><ul><li>If two objects are equal, they MUST have the same hash code</li><li>If two objects have the same hash code, they are NOT necessarily equal</li></ul><p><strong>Implementation example:</strong></p><pre><code>public class Person {\n    private final String firstName;\n    private final String lastName;\n    private final int age;\n    \n    // Constructor and getters omitted\n    \n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;  // Same reference\n        if (o == null || getClass() != o.getClass()) return false;  // Null or different class\n        \n        Person person = (Person) o;\n        return age == person.age && \n               Objects.equals(firstName, person.firstName) &&\n               Objects.equals(lastName, person.lastName);\n    }\n    \n    @Override\n    public int hashCode() {\n        return Objects.hash(firstName, lastName, age);\n    }\n}</code></pre><p><strong>Common pitfalls:</strong></p><ul><li>Forgetting to override hashCode() when overriding equals()</li><li>Using mutable fields in hashCode() (can break hash-based collections)</li><li>Incorrect handling of null fields</li><li>Poor hash distribution (using only one field)</li><li>Expensive hash computation (e.g., deep hash of complex objects)</li></ul><p><strong>Best practices:</strong></p><ul><li>Override both methods when implementing custom equality</li><li>Use IDE-generated implementations or libraries like Apache Commons Lang</li><li>Use Objects.equals() and Objects.hash() (Java 7+)</li><li>Consider using immutable objects</li><li>For complex objects, cache hashCode() value for performance</li></ul>",
    "category": "Core Java",
    "difficulty": "medium"
  },
  {
    "question": "What are Java's built-in thread synchronization mechanisms?",
    "answer": "<p>Java provides several mechanisms for thread synchronization:</p><p><strong>1. synchronized keyword:</strong></p><ul><li>Can be applied to methods or blocks</li><li>Acquires intrinsic lock (monitor) on an object</li><li>Establishes happens-before relationship</li><li>Only one thread can execute synchronized code for a given lock at a time</li></ul><pre><code>// Synchronized method\npublic synchronized void synchronizedMethod() {\n    // Only one thread can execute this method on this object instance at a time\n}\n\n// Synchronized block\npublic void synchronizedBlock() {\n    synchronized(this) {\n        // Only one thread can execute this block on this object instance at a time\n    }\n}\n\n// Synchronized on class\npublic static synchronized void synchronizedStaticMethod() {\n    // Only one thread can execute this method at a time, regardless of instance\n}</code></pre><p><strong>2. volatile keyword:</strong></p><ul><li>Guarantees visibility of changes to variables across threads</li><li>Prevents compiler optimizations that could cause visibility issues</li><li>Does not provide atomicity for compound operations</li></ul><pre><code>private volatile boolean flag = false;</code></pre><p><strong>3. wait(), notify(), and notifyAll():</strong></p><ul><li>Methods of Object class for thread communication</li><li>Must be called from synchronized context</li><li>wait(): releases lock and waits for notification</li><li>notify(): wakes up a single waiting thread</li><li>notifyAll(): wakes up all waiting threads</li></ul><pre><code>synchronized(lock) {\n    while(!condition) {\n        lock.wait(); // Release lock and wait\n    }\n    // Condition met, do work\n}\n\n// In another thread\nsynchronized(lock) {\n    // Change condition\n    condition = true;\n    lock.notifyAll(); // Wake up waiting threads\n}</code></pre><p><strong>4. java.util.concurrent package:</strong></p><ul><li><strong>Lock interface:</strong> More flexible than synchronized</li><li><strong>ReentrantLock:</strong> Basic lock implementation</li><li><strong>ReadWriteLock:</strong> Separate locks for reading and writing</li><li><strong>Condition:</strong> Alternative to wait/notify</li><li><strong>Atomic classes:</strong> AtomicInteger, AtomicLong, etc.</li><li><strong>ConcurrentHashMap:</strong> Thread-safe collections</li><li><strong>CountDownLatch, CyclicBarrier, Semaphore:</strong> Synchronizers</li></ul><pre><code>Lock lock = new ReentrantLock();\nCondition condition = lock.newCondition();\n\ntry {\n    lock.lock();\n    while(!conditionMet) {\n        condition.await(); // Similar to wait()\n    }\n    // Do work\n} finally {\n    lock.unlock(); // Must manually unlock\n}\n\n// In another thread\nlock.lock();\ntry {\n    // Change condition\n    conditionMet = true;\n    condition.signalAll(); // Similar to notifyAll()\n} finally {\n    lock.unlock();\n}</code></pre>",
    "category": "Multithreading",
    "difficulty": "medium"
  },
  {
    "question": "What is the difference between Comparator and Comparable in Java?",
    "answer": "<p><strong>Comparable:</strong></p><ul><li>Part of java.lang package</li><li>Interface with a single method: <code>compareTo(T o)</code></li><li>Provides natural ordering of a class</li><li>Classes implement this interface to define their default sort order</li><li>Used by Collections.sort() and Arrays.sort() without explicit comparator</li></ul><p><strong>Comparator:</strong></p><ul><li>Part of java.util package</li><li>Functional interface with method: <code>compare(T o1, T o2)</code></li><li>Provides custom ordering separate from the class itself</li><li>External to the class being compared</li><li>Allows multiple different sort orders</li><li>Can sort classes that don't implement Comparable</li></ul><p><strong>Example of Comparable:</strong></p><pre><code>public class Person implements Comparable&lt;Person&gt; {\n    private String name;\n    private int age;\n    \n    // Constructor and getters omitted\n    \n    @Override\n    public int compareTo(Person other) {\n        // Sort by name\n        return this.name.compareTo(other.name);\n    }\n}\n\n// Usage\nList&lt;Person&gt; people = new ArrayList&lt;&gt;();\n// Add people to the list\nCollections.sort(people); // Uses natural ordering</code></pre><p><strong>Example of Comparator:</strong></p><pre><code>// Sort by age\nComparator&lt;Person&gt; ageComparator = new Comparator&lt;Person&gt;() {\n    @Override\n    public int compare(Person p1, Person p2) {\n        return Integer.compare(p1.getAge(), p2.getAge());\n    }\n};\n\n// Java 8 Lambda\nComparator&lt;Person&gt; ageComparatorLambda = (p1, p2) -> Integer.compare(p1.getAge(), p2.getAge());\n\n// Usage\nCollections.sort(people, ageComparator); // Custom ordering\n\n// Java 8 with method reference\npeople.sort(Comparator.comparing(Person::getAge));</code></pre><p><strong>Key differences:</strong></p><table><tr><th>Feature</th><th>Comparable</th><th>Comparator</th></tr><tr><td>Package</td><td>java.lang</td><td>java.util</td></tr><tr><td>Method</td><td>compareTo(T o)</td><td>compare(T o1, T o2)</td></tr><tr><td>Implementation</td><td>Class itself implements</td><td>Separate class implements</td></tr><tr><td>Number of orderings</td><td>Single (natural)</td><td>Multiple possible</td></tr><tr><td>Control</td><td>Need class source code</td><td>Can sort without modifying class</td></tr><tr><td>Usage</td><td>Collections.sort(list)</td><td>Collections.sort(list, comparator)</td></tr></table><p><strong>Common applications:</strong></p><ul><li>Comparable: String, Date, numeric wrapper classes</li><li>Comparator: Custom sort orders, complex sorting logic, database query result ordering</li></ul>",
    "category": "Collections",
    "difficulty": "medium"
  },
  {
    "question": "Explain Java's try-with-resources statement.",
    "answer": "<p>Try-with-resources is a language feature introduced in Java 7 to automatically handle resource management and cleanup.</p><p><strong>Purpose:</strong></p><ul><li>Automatically closes resources that implement AutoCloseable interface</li><li>Eliminates verbose finally blocks for resource cleanup</li><li>Ensures resources are properly closed even if exceptions occur</li><li>Handles multiple resources in a structured way</li></ul><p><strong>Basic syntax:</strong></p><pre><code>try (Resource resource = new Resource()) {\n    // Use the resource\n} // Resource automatically closed at end of block</code></pre><p><strong>Example with file operations:</strong></p><pre><code>// Before Java 7\nBufferedReader br = null;\ntry {\n    br = new BufferedReader(new FileReader(\"file.txt\"));\n    String line = br.readLine();\n    System.out.println(line);\n} catch (IOException e) {\n    e.printStackTrace();\n} finally {\n    if (br != null) {\n        try {\n            br.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\n// With try-with-resources\ntry (BufferedReader br = new BufferedReader(new FileReader(\"file.txt\"))) {\n    String line = br.readLine();\n    System.out.println(line);\n} catch (IOException e) {\n    e.printStackTrace();\n}</code></pre><p><strong>Multiple resources:</strong></p><pre><code>try (InputStream in = new FileInputStream(\"input.txt\");\n     OutputStream out = new FileOutputStream(\"output.txt\")) {\n    // Use in and out\n    byte[] buffer = new byte[1024];\n    int bytesRead;\n    while ((bytesRead = in.read(buffer)) != -1) {\n        out.write(buffer, 0, bytesRead);\n    }\n}</code></pre><p><strong>Exception handling:</strong></p><ul><li>Resources are closed in reverse order of their creation</li><li>If both the try block and the close() method throw exceptions, the try block exception is thrown and close exceptions are suppressed</li><li>Suppressed exceptions can be accessed via the getSuppressed() method</li></ul><pre><code>try (AutoCloseableResource resource = new AutoCloseableResource()) {\n    throw new Exception(\"Try block exception\");\n} catch (Exception e) {\n    System.out.println(\"Caught: \" + e.getMessage());\n    for (Throwable suppressed : e.getSuppressed()) {\n        System.out.println(\"Suppressed: \" + suppressed.getMessage());\n    }\n}</code></pre><p><strong>Enhancements in Java 9:</strong></p><ul><li>Resources can be declared outside the try block if they are effectively final</li></ul><pre><code>// Java 9+\nBufferedReader br = new BufferedReader(new FileReader(\"file.txt\"));\ntry (br) {\n    // Use the resource\n}</code></pre>",
    "category": "Core Java",
    "difficulty": "easy"
  },
  {
    "question": "How do you handle database transactions in Spring?",
    "answer": "<p>Spring provides comprehensive support for transaction management using both programmatic and declarative approaches.</p><p><strong>1. Declarative Transaction Management:</strong></p><ul><li>Preferred approach in most cases</li><li>Uses annotations or XML configuration</li><li>Separation of business and transaction logic</li></ul><p><strong>Using @Transactional annotation:</strong></p><pre><code>// Enable transactions (in configuration class)\n@Configuration\n@EnableTransactionManagement\npublic class AppConfig {\n    // Transaction manager beans\n}\n\n// Using @Transactional\n@Service\npublic class UserService {\n    @Autowired\n    private UserRepository userRepository;\n    \n    @Transactional  // Default: propagation=REQUIRED, readOnly=false\n    public void createUser(User user) {\n        userRepository.save(user);\n        // If any exception occurs, transaction will be rolled back\n    }\n    \n    @Transactional(readOnly = true)\n    public User getUserById(Long id) {\n        return userRepository.findById(id).orElse(null);\n    }\n    \n    @Transactional(propagation = Propagation.REQUIRES_NEW,\n                 isolation = Isolation.SERIALIZABLE,\n                 timeout = 30,\n                 rollbackFor = {SQLException.class},\n                 noRollbackFor = {DataAccessException.class})\n    public void complexOperation() {\n        // Complex transactional operation\n    }\n}</code></pre><p><strong>2. Programmatic Transaction Management:</strong></p><ul><li>Provides more fine-grained control</li><li>More verbose than declarative approach</li></ul><pre><code>@Service\npublic class UserService {\n    @Autowired\n    private PlatformTransactionManager transactionManager;\n    \n    public void createUser(User user) {\n        TransactionDefinition txDef = new DefaultTransactionDefinition();\n        TransactionStatus txStatus = transactionManager.getTransaction(txDef);\n        \n        try {\n            // Perform operations\n            userRepository.save(user);\n            \n            // Commit transaction\n            transactionManager.commit(txStatus);\n        } catch (Exception e) {\n            // Roll back transaction\n            transactionManager.rollback(txStatus);\n            throw e;\n        }\n    }\n    \n    // Using TransactionTemplate\n    @Autowired\n    private TransactionTemplate transactionTemplate;\n    \n    public User createUserWithTemplate(User user) {\n        return transactionTemplate.execute(status -> {\n            userRepository.save(user);\n            return user;\n        });\n    }\n}</code></pre><p><strong>Transaction Propagation Options:</strong></p><ul><li><strong>REQUIRED (default):</strong> Use current transaction, create new if none exists</li><li><strong>REQUIRES_NEW:</strong> Create new transaction, suspend current if exists</li><li><strong>SUPPORTS:</strong> Use current transaction if exists, otherwise non-transactional</li><li><strong>NOT_SUPPORTED:</strong> Execute non-transactionally, suspend current if exists</li><li><strong>MANDATORY:</strong> Use current transaction, throw exception if none exists</li><li><strong>NEVER:</strong> Execute non-transactionally, throw exception if transaction exists</li><li><strong>NESTED:</strong> Execute in nested transaction if exists, like REQUIRED otherwise</li></ul><p><strong>Isolation Levels:</strong></p><ul><li><strong>DEFAULT:</strong> Database default isolation level</li><li><strong>READ_UNCOMMITTED:</strong> Allows dirty reads, non-repeatable reads, phantom reads</li><li><strong>READ_COMMITTED:</strong> Prevents dirty reads, allows non-repeatable reads, phantom reads</li><li><strong>REPEATABLE_READ:</strong> Prevents dirty and non-repeatable reads, allows phantom reads</li><li><strong>SERIALIZABLE:</strong> Prevents all concurrency issues, but lowest performance</li></ul>",
    "category": "Spring & Hibernate",
    "difficulty": "medium"
  },
  {
    "question": "What is the Factory Design Pattern and when should you use it?",
    "answer": "<p>The Factory Design Pattern is a creational pattern that provides an interface for creating objects without specifying their concrete classes.</p><p><strong>Types of Factory patterns:</strong></p><ol><li><strong>Simple Factory:</strong> Not a formal pattern but a common technique</li><li><strong>Factory Method:</strong> Defines an interface for creating objects, but subclasses decide which class to instantiate</li><li><strong>Abstract Factory:</strong> Creates families of related objects without specifying concrete classes</li></ol><p><strong>1. Simple Factory:</strong></p><pre><code>// Product interface\npublic interface Vehicle {\n    void drive();\n}\n\n// Concrete products\npublic class Car implements Vehicle {\n    @Override\n    public void drive() {\n        System.out.println(\"Driving a car\");\n    }\n}\n\npublic class Bike implements Vehicle {\n    @Override\n    public void drive() {\n        System.out.println(\"Riding a bike\");\n    }\n}\n\n// Simple Factory\npublic class VehicleFactory {\n    public static Vehicle createVehicle(String type) {\n        if (\"car\".equalsIgnoreCase(type)) {\n            return new Car();\n        } else if (\"bike\".equalsIgnoreCase(type)) {\n            return new Bike();\n        }\n        throw new IllegalArgumentException(\"Unknown vehicle type\");\n    }\n}\n\n// Client code\nVehicle car = VehicleFactory.createVehicle(\"car\");\ncar.drive();</code></pre><p><strong>2. Factory Method:</strong></p><pre><code>// Creator - abstract class with factory method\npublic abstract class VehicleFactory {\n    // Factory method\n    public abstract Vehicle createVehicle();\n    \n    // Common operations using the factory method\n    public void useVehicle() {\n        Vehicle vehicle = createVehicle();\n        vehicle.drive();\n    }\n}\n\n// Concrete creators\npublic class CarFactory extends VehicleFactory {\n    @Override\n    public Vehicle createVehicle() {\n        return new Car();\n    }\n}\n\npublic class BikeFactory extends VehicleFactory {\n    @Override\n    public Vehicle createVehicle() {\n        return new Bike();\n    }\n}\n\n// Client code\nVehicleFactory factory = new CarFactory();\nfactory.useVehicle(); // Creates Car and calls drive()</code></pre><p><strong>3. Abstract Factory:</strong></p><pre><code>// Product interfaces\npublic interface Engine {\n    void start();\n}\n\npublic interface Body {\n    void assemble();\n}\n\n// Concrete products\npublic class CarEngine implements Engine {\n    @Override\n    public void start() {\n        System.out.println(\"Car engine started\");\n    }\n}\n\npublic class BikeEngine implements Engine {\n    @Override\n    public void start() {\n        System.out.println(\"Bike engine started\");\n    }\n}\n\npublic class CarBody implements Body {\n    @Override\n    public void assemble() {\n        System.out.println(\"Car body assembled\");\n    }\n}\n\npublic class BikeBody implements Body {\n    @Override\n    public void assemble() {\n        System.out.println(\"Bike body assembled\");\n    }\n}\n\n// Abstract factory\npublic interface VehicleFactory {\n    Engine createEngine();\n    Body createBody();\n}\n\n// Concrete factories\npublic class CarFactory implements VehicleFactory {\n    @Override\n    public Engine createEngine() {\n        return new CarEngine();\n    }\n    \n    @Override\n    public Body createBody() {\n        return new CarBody();\n    }\n}\n\npublic class BikeFactory implements VehicleFactory {\n    @Override\n    public Engine createEngine() {\n        return new BikeEngine();\n    }\n    \n    @Override\n    public Body createBody() {\n        return new BikeBody();\n    }\n}\n\n// Client code\nVehicleFactory factory = new CarFactory();\nEngine engine = factory.createEngine();\nBody body = factory.createBody();\nengine.start();\nbody.assemble();</code></pre><p><strong>Benefits of Factory Pattern:</strong></p><ul><li>Decouples client code from concrete implementations</li><li>Makes adding new products easier</li><li>Encapsulates object creation logic</li><li>Promotes consistency in object creation</li><li>Implements the Single Responsibility Principle</li></ul><p><strong>Use cases:</strong></p><ul><li>When a class can't anticipate the type of objects it must create</li><li>When a class wants its subclasses to specify objects it creates</li><li>When you want to hide the implementation details of products</li><li>When you need to work with families of related products</li><li>Example: GUI libraries creating components for different operating systems</li></ul>",
    "category": "Design Patterns",
    "difficulty": "medium"
  },
  {
    "question": "How are Java lambdas implemented under the hood?",
    "answer": "<p>Java lambdas were introduced in Java 8 as a way to implement functional interfaces more concisely. Their internal implementation involves several key mechanisms:</p><p><strong>1. Functional Interfaces:</strong></p><ul><li>Lambdas implement functional interfaces - interfaces with a single abstract method</li><li>Annotated with @FunctionalInterface (optional but recommended)</li><li>Examples: Runnable, Callable, Predicate, Function, Consumer, Supplier</li></ul><p><strong>2. Translation to Anonymous Classes:</strong></p><ul><li>Conceptually, lambdas are syntactic sugar for anonymous inner classes</li><li>However, they're not directly implemented as anonymous classes at bytecode level</li></ul><p><strong>3. Invokedynamic Instruction:</strong></p><ul><li>Java uses the invokedynamic instruction (introduced in Java 7)</li><li>Defers the binding of method calls until runtime</li><li>Allows JVM to optimize lambda implementations</li></ul><p><strong>4. Lambda Metafactory:</strong></p><ul><li>java.lang.invoke.LambdaMetafactory handles the conversion</li><li>Generates a class or uses an existing one to implement the functional interface</li><li>Links the lambda body to the abstract method in the interface</li></ul><p><strong>5. Strategies for Lambda Implementation:</strong></p><ul><li><strong>Anonymous class generation:</strong> Similar to pre-Java 8, but more optimized</li><li><strong>Method references:</strong> Can be implemented as direct method handles</li><li><strong>Specialized lambda forms:</strong> For common functional interfaces</li></ul><p><strong>6. Capturing vs. Non-capturing Lambdas:</strong></p><ul><li><strong>Non-capturing lambdas:</strong> Don't use variables from enclosing scope</li><li>Can be more efficiently implemented (potentially stateless singletons)</li><li><strong>Capturing lambdas:</strong> Use variables from enclosing scope</li><li>Require storage for captured variables</li></ul><p><strong>Example of captured variables:</strong></p><pre><code>int factor = 5;\n\n// Capturing lambda\nFunction&lt;Integer, Integer&gt; multiplier = x -> x * factor;\n\n// Conceptually similar to:\nFunction&lt;Integer, Integer&gt; multiplierAnon = new Function&lt;Integer, Integer&gt;() {\n    final int capturedFactor = factor;  // Variable is captured/copied\n    \n    @Override\n    public Integer apply(Integer x) {\n        return x * capturedFactor;\n    }\n};</code></pre><p><strong>7. Performance Considerations:</strong></p><ul><li>Lambdas generally outperform anonymous classes</li><li>Non-capturing lambdas can be more efficiently implemented</li><li>Method references can be more efficient than equivalent lambdas</li><li>JIT compiler can inline and optimize lambda code paths</li></ul><p><strong>8. Serialization:</strong></p><ul><li>Lambdas are not inherently serializable</li><li>Can be serialized if the functional interface is serializable and all captured variables are serializable</li><li>Serialized form not guaranteed across JVM implementations or versions</li></ul>",
    "category": "Core Java",
    "difficulty": "hard"
  },
  {
    "question": "Explain time and space complexity analysis for common data structures in Java.",
    "answer": "<p>Here's a comparison of common data structures in Java and their time/space complexity:</p><p><strong>Arrays:</strong></p><ul><li>Access: O(1)</li><li>Search (unsorted): O(n)</li><li>Search (sorted): O(log n) using binary search</li><li>Insertion/Deletion: O(n) due to shifting elements</li><li>Space: O(n)</li></ul><p><strong>ArrayList:</strong></p><ul><li>Access: O(1)</li><li>Search: O(n)</li><li>Insertion/Deletion at end: Amortized O(1)</li><li>Insertion/Deletion at arbitrary position: O(n)</li><li>Space: O(n)</li></ul><p><strong>LinkedList:</strong></p><ul><li>Access: O(n)</li><li>Search: O(n)</li><li>Insertion/Deletion at beginning/end: O(1)</li><li>Insertion/Deletion at known position: O(1)</li><li>Insertion/Deletion at arbitrary position: O(n) to find position</li><li>Space: O(n)</li></ul><p><strong>HashMap:</strong></p><ul><li>Search/Insertion/Deletion: Average O(1), Worst O(n)</li><li>Iteration: O(capacity + size)</li><li>Space: O(n)</li></ul><p><strong>TreeMap:</strong></p><ul><li>Search/Insertion/Deletion: O(log n)</li><li>Space: O(n)</li></ul><p><strong>HashSet:</strong></p><ul><li>Search/Insertion/Deletion: Average O(1), Worst O(n)</li><li>Space: O(n)</li></ul><p><strong>TreeSet:</strong></p><ul><li>Search/Insertion/Deletion: O(log n)</li><li>Space: O(n)</li></ul><p><strong>PriorityQueue:</strong></p><ul><li>Peek: O(1)</li><li>Poll/Remove: O(log n)</li><li>Add/Offer: O(log n)</li><li>Space: O(n)</li></ul><p><strong>Stack:</strong></p><ul><li>Push/Pop/Peek: O(1)</li><li>Search: O(n)</li><li>Space: O(n)</li></ul><p><strong>Queue (LinkedList implementation):</strong></p><ul><li>Enqueue/Dequeue: O(1)</li><li>Peek: O(1)</li><li>Space: O(n)</li></ul>",
    "category": "Data Structures",
    "difficulty": "medium"
  },
  {
    "question": "Explain binary trees and their traversal algorithms in Java.",
    "answer": "<p>Binary trees are hierarchical data structures where each node has at most two child nodes, typically referred to as left and right children.</p><p><strong>Types of Binary Trees:</strong></p><ul><li><strong>Full Binary Tree:</strong> Each node has either 0 or 2 children</li><li><strong>Complete Binary Tree:</strong> All levels are filled except possibly the last, which is filled from left to right</li><li><strong>Perfect Binary Tree:</strong> All internal nodes have exactly two children and all leaf nodes are at the same level</li><li><strong>Balanced Binary Tree:</strong> Height is O(log n) where n is the number of nodes</li><li><strong>Binary Search Tree (BST):</strong> Left child < Parent < Right child</li></ul><p><strong>Basic Implementation:</strong></p><pre><code>class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    \n    TreeNode(int val) {\n        this.val = val;\n    }\n}</code></pre><p><strong>Traversal Algorithms:</strong></p><p>1. <strong>Depth-First Traversals:</strong></p><pre><code>// Inorder (Left, Root, Right)\nvoid inorder(TreeNode root) {\n    if (root == null) return;\n    inorder(root.left);\n    System.out.print(root.val + \" \");\n    inorder(root.right);\n}\n\n// Preorder (Root, Left, Right)\nvoid preorder(TreeNode root) {\n    if (root == null) return;\n    System.out.print(root.val + \" \");\n    preorder(root.left);\n    preorder(root.right);\n}\n\n// Postorder (Left, Right, Root)\nvoid postorder(TreeNode root) {\n    if (root == null) return;\n    postorder(root.left);\n    postorder(root.right);\n    System.out.print(root.val + \" \");\n}</code></pre><p>2. <strong>Breadth-First Traversal (Level Order):</strong></p><pre><code>void levelOrder(TreeNode root) {\n    if (root == null) return;\n    \n    Queue<TreeNode> queue = new LinkedList<>();\n    queue.add(root);\n    \n    while (!queue.isEmpty()) {\n        TreeNode node = queue.poll();\n        System.out.print(node.val + \" \");\n        \n        if (node.left != null) queue.add(node.left);\n        if (node.right != null) queue.add(node.right);\n    }\n}</code></pre><p><strong>Applications:</strong></p><ul><li>Expression evaluation</li><li>File system organization</li><li>Database indexing (B-trees, B+ trees)</li><li>Decision trees in AI</li><li>Huffman coding</li></ul>",
    "category": "Data Structures",
    "difficulty": "medium"
  },
  {
    "question": "Explain the concept of microservices architecture and its advantages/disadvantages.",
    "answer": "<p>Microservices architecture is an approach to building applications as a collection of small, independent services that communicate over well-defined APIs.</p><p><strong>Key Characteristics:</strong></p><ul><li>Services are organized around business capabilities</li><li>Each service has a single responsibility</li><li>Services are independently deployable</li><li>Services are loosely coupled</li><li>Each service can use its own technology stack</li><li>Each service has its own database</li></ul><p><strong>Advantages:</strong></p><ul><li><strong>Technology Flexibility:</strong> Different services can use different technologies</li><li><strong>Scalability:</strong> Individual services can be scaled independently</li><li><strong>Resilience:</strong> Failure in one service doesn't bring down the entire application</li><li><strong>Deployment:</strong> Faster, independent deployments</li><li><strong>Team Organization:</strong> Different teams can work on different services</li><li><strong>Maintainability:</strong> Smaller codebases are easier to understand</li><li><strong>Testability:</strong> Services can be tested in isolation</li></ul><p><strong>Disadvantages:</strong></p><ul><li><strong>Distributed System Complexity:</strong> Network latency, message formats, load balancing</li><li><strong>Operational Complexity:</strong> More services to deploy, monitor, and manage</li><li><strong>Transaction Management:</strong> Maintaining data consistency across services is challenging</li><li><strong>Testing:</strong> Integration testing becomes more complex</li><li><strong>Deployment:</strong> Requires sophisticated deployment pipelines</li><li><strong>Resource Overhead:</strong> Each service has its runtime environment</li><li><strong>Service Boundaries:</strong> Determining correct service boundaries is challenging</li></ul><p><strong>Implementation Patterns:</strong></p><ul><li><strong>API Gateway:</strong> Single entry point for clients</li><li><strong>Service Discovery:</strong> Dynamically finding service instances</li><li><strong>Circuit Breaker:</strong> Preventing cascading failures</li><li><strong>CQRS:</strong> Separating read and write operations</li><li><strong>Event Sourcing:</strong> Storing changes as events</li><li><strong>Saga Pattern:</strong> Managing distributed transactions</li><li><strong>Bulkhead Pattern:</strong> Isolating failures</li></ul><p><strong>Tools/Technologies in Java:</strong></p><ul><li><strong>Spring Boot/Cloud:</strong> Building microservices</li><li><strong>Netflix OSS:</strong> Eureka, Hystrix, Zuul, Ribbon</li><li><strong>Kubernetes:</strong> Container orchestration</li><li><strong>Docker:</strong> Containerization</li><li><strong>Kafka/RabbitMQ:</strong> Messaging</li><li><strong>Prometheus/Grafana:</strong> Monitoring</li><li><strong>ELK Stack:</strong> Logging</li><li><strong>Jaeger/Zipkin:</strong> Distributed tracing</li></ul>",
    "category": "System Design",
    "difficulty": "hard"
  },
  {
    "question": "Explain database scaling techniques (vertical vs horizontal) and their implementations.",
    "answer": "<p>Database scaling is essential for handling increasing load, and there are two primary approaches: vertical and horizontal scaling.</p><p><strong>Vertical Scaling (Scale Up):</strong></p><ul><li><strong>Definition:</strong> Adding more resources (CPU, RAM, storage) to a single server</li><li><strong>Advantages:</strong><ul><li>Simpler to implement</li><li>No distribution complexity</li><li>No application changes typically required</li><li>Better for read/write intensive workloads</li></ul></li><li><strong>Disadvantages:</strong><ul><li>Hardware limitations (ceiling on how much you can scale)</li><li>Higher costs for high-end hardware</li><li>Single point of failure</li><li>Downtime during upgrades</li></ul></li><li><strong>Implementation:</strong><ul><li>Upgrading server hardware</li><li>Database parameter tuning</li><li>Query optimization</li><li>Proper indexing</li><li>Caching (Redis, Memcached)</li></ul></li></ul><p><strong>Horizontal Scaling (Scale Out):</strong></p><ul><li><strong>Definition:</strong> Adding more servers to distribute the load</li><li><strong>Advantages:</strong><ul><li>Theoretically unlimited scaling</li><li>Better fault tolerance</li><li>Can use commodity hardware</li><li>Less expensive incremental scaling</li></ul></li><li><strong>Disadvantages:</strong><ul><li>Increased complexity</li><li>Data distribution challenges</li><li>Consistency challenges</li><li>Application changes often required</li></ul></li><li><strong>Implementation Strategies:</strong><ul><li><strong>Sharding:</strong> Partitioning data across multiple database instances<ul><li>Vertical sharding: Splitting tables across databases</li><li>Horizontal sharding: Splitting rows across databases</li><li>Sharding keys: Determining which shard holds which data</li></ul></li><li><strong>Replication:</strong> Copying data to multiple servers<ul><li>Master-slave: Writes to master, reads from slaves</li><li>Multi-master: Writes to multiple masters</li><li>Circular replication: All nodes can accept writes</li></ul></li></ul></li></ul><p><strong>Combined Approaches:</strong></p><ul><li>Vertical scaling for specific components (e.g., memory-intensive caching servers)</li><li>Horizontal scaling for the overall database architecture</li><li>Read replicas for read-heavy workloads</li><li>Caching layers to reduce database load</li></ul><p><strong>Java Implementation Considerations:</strong></p><ul><li><strong>Connection pooling:</strong> HikariCP, Apache DBCP</li><li><strong>ORM configurations:</strong> Hibernate/JPA sharding support</li><li><strong>Sharding frameworks:</strong> Apache Shardingsphere</li><li><strong>Custom data routing logic:</strong> For application-level sharding</li><li><strong>Read/write splitting:</strong> For master-slave architectures</li></ul><p><strong>Modern Solutions:</strong></p><ul><li><strong>NoSQL databases:</strong> MongoDB, Cassandra, designed for horizontal scaling</li><li><strong>NewSQL databases:</strong> CockroachDB, Google Spanner, combining SQL with horizontal scaling</li><li><strong>Distributed caching:</strong> Redis Cluster, Hazelcast</li><li><strong>Database-as-a-Service:</strong> Amazon RDS, Google Cloud SQL with auto-scaling</li></ul>",
    "category": "System Design",
    "difficulty": "hard"
  }
]
